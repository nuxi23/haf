'add roll command?
'add local scope?
'add debug mode?
'Mouse style loops?
'remove builtins and replace with standard library?



'haf.bas
'a half-assed stack-based language
'that's halfway between forth and lisp


'10 Main loop
'100 lexer / eval
'200 dictionary search
'300 stack handling
'1000 primitives
'10000 dictionary array
'15000 help

PRINT "HAF - A haf-assd programng languag"
PRINT "by Nuxi"
PRINT "v 0.99"
PRINT "try HELP"
PRINT "manual on PUB"

STACK$(0) = ""
STACKPTR = 0
ENVSTACK$(0) = ""
ENVSTACKPTR = 0


TRUE$ = "1"
FALSE$ = "0"


GOSUB 10000 'Get primitive dictionary
GOSUB 10100 'get builtin dictionary


'********************Load file
IF ARGC% < 2 THEN GOTO 50 'No command line arguments
FOR J = 1 TO ARGC% -1
10	OPEN ARGV$(J), AS #2
20  IF EOF(2) THEN GOTO 30
    INPUT# 2, READLN$
    GOSUB 100
    GOTO 20
    30  CLOSE #2

NEXT J


'********************Main loop
50 PRINT STACKPTR;
INPUT ">", READLN$ : IF READLN$ = "" GOTO 50
GOSUB 100 'lexer / eval
GOTO 50

'********************lexer / eval

'This section ... works, kinda
'It was my first go at it, and was always intended as a placeholder
'There are two main issues:
'1) it starts going deep on subroutine calls quickly, limiting both
'how many statements you can execute in a program, and how much recursion
'is possible
'2) the parsing of parens '()' is horribly kludgy, and will accidentally execute
'anything after, as if returning from a recursion. You can get around this
'by creating a word that ends with the closing paren, or you can just rewrite it




100  READLN$=TH_SED$(READLN$,"(^\s+)+","") 'remove leading and trailing spaces

IF LEFT$(READLN$,1)="~" THEN 110
IF LEFT$(READLN$,1)="{" THEN 120
IF LEFT$(READLN$,1)="(" THEN 130
IF LEFT$(READLN$,1)="[" THEN 140

IF TH_RE(READLN$,"\s")<1 THEN CURTOKEN$ = READLN$ : GOSUB 200 : RETURN 'just an atom

CDR$= RIGHT$(READLN$,LEN(READLN$) -POS(READLN$," ")) 'set cdr
CURTOKEN$ = LEFT$(READLN$,POS(READLN$," ")-1) 			 'set car

GOSUB 200

READLN$ = CDR$
GOSUB 100 : RETURN

'*********** comments
110 BRACES=1
FOR I = 2 TO LEN(READLN$)-1
	CURCHAR$ =MID$(READLN$,I,1)
	IF CURCHAR$ = "~" THEN BRACES = BRACES - 1
	IF BRACES = 0 THEN GOTO 115
NEXT I
RETURN



115 READLN$ = RIGHT$(READLN$,LEN(READLN$)-I) 
GOTO 100




'*********** standard braces
120 BRACES=1
FOR I = 2 TO LEN(READLN$)-1
	CURCHAR$ =MID$(READLN$,I,1)
	IF CURCHAR$ = "}" THEN BRACES = BRACES - 1
	IF CURCHAR$ = "{" THEN BRACES = BRACES + 1
	IF BRACES = 0 THEN GOTO 125
NEXT I
CURTOKEN$ = MID$(READLN$,2,LEN(READLN$)-2) : GOSUB 300 : RETURN 'got all the way through, this is the only literal

125 CDR$= RIGHT$(READLN$,LEN(READLN$)-I)
CURTOKEN$ = MID$(READLN$,2,I-2)
GOSUB 300
READLN$ = CDR$
GOSUB 100 : RETURN



'******** parens
130 BRACES=1
FOR I = 2 TO LEN(READLN$)-1
	CURCHAR$ =MID$(READLN$,I,1)
	IF CURCHAR$ = ")" THEN BRACES = BRACES - 1
	IF CURCHAR$ = "(" THEN BRACES = BRACES + 1
	IF BRACES = 0 THEN GOTO 135
NEXT I

'got all the way through
    READLNTEMP$ = MID$(READLN$,2,LEN(READLN$)-2) 'jeeeezus, clean this up ASAP
133 GOSUB 310 : IF CURTOKEN$ = FALSE$ THEN RETURN
134 GOSUB 300
	READLN$ = READLNTEMP$
	GOSUB 100
GOTO 133

135 GOSUB 310
IF CURTOKEN$ = FALSE$ THEN READLN$ = MID$(READLN$,I+1,LEN(READLN$)-I) : GOTO 100
  READLNTEMP$ = MID$(READLN$,2,I-2)  'I am some kind of monster
  CDR$ = MID$(READLN$,I+1,LEN(READLN$)-I) 
    GOSUB 134
 GOTO 100



'*********** square braces
140 BRACES=1
FOR I = 2 TO LEN(READLN$)-1
	CURCHAR$ =MID$(READLN$,I,1)
	IF CURCHAR$ = "]" THEN BRACES = BRACES - 1
	IF CURCHAR$ = "[" THEN BRACES = BRACES + 1
	IF BRACES = 0 THEN GOTO 145
NEXT I

'got all the way through
GOSUB 310
IF CURTOKEN$ <> FALSE$ THEN READLN$ = MID$(READLN$,2,LEN(READLN$)-2) : GOSUB 100 : RETURN
RETURN

145 GOSUB 310
IF CURTOKEN$ = FALSE$ THEN READLN$ = MID$(READLN$,I+1,LEN(READLN$)-I) : GOSUB 100 : RETURN
READLN$ = MID$(READLN$,2,I-2) + " " + MID$(READLN$,I+1,LEN(READLN$)-I) :GOSUB 100 : RETURN


150 RETURN





'********************Dictionary search

200 IF POS(DICTIONARY$(1), " " + UPS$(CURTOKEN$) + " " ) > 0 THEN 220 ' defined -- making space for if I end up adding local scope
	IF POS(DICTIONARY$(0), " " + UPS$(CURTOKEN$) + " " ) > 0 THEN 210 ' primitive dictionary

GOSUB 300 'not in dictionary, so push value to stack
RETURN

'primitives
210 ON WORDPOS(UPS$(CURTOKEN$)) GOSUB 1000, 1010, 1020, 1030, 1040, 1050, 1060, 1070, 1080, 1090, 1100, 1110, 1120, 1130, 1140, 1150, 1160, 1170, 1180, 1190, 1200, 1210, 1220, 1230, 1240, 1250, 1260, 1270, 1280, 1290, 1300, 1310, 1320, 1330, 1340, 1350, 1360, 1370, 1380, 1390, 1400, 1410, 1420, 1430, 1440, 1450, 1460, 1470, 1480, 1490, 1500, 1510, 1520, 1530, 1540, 1550, 1560, 1570, 1580, 1590, 1600, 1610, 1620, 1630, 1640, 1650, 1660, 1670, 1680, 1690, 1700, 1710, 1720, 1730, 1740, 1750, 1760, 1770, 1780, 1790, 1800, 1810, 1820, 1830, 1840, 1850, 1860, 1870, 1880, 1890, 1900, 1910, 1920, 1930, 1940, 1950, 1960, 1970, 1980, 1990, 2000, 2010, 2020, 2030, 2040, 2050, 2060, 2070, 2080, 2090, 2100, 2110, 2120, 2130, 2140, 2150, 2160, 2170, 2180, 2190, 2200, 2210, 2220, 2230, 2240, 2250, 2260, 2270, 2280, 2290, 2300, 2310,15000
RETURN

'builtins and user-defined words
220 GOSUB 350
 
	CURTOKEN$ = UPS$(CURTOKEN$)
    READLN$ = DICTDEF$(CURTOKEN$)
	GOSUB 100
	 

    GOSUB 360

RETURN


'push
300 STACK$(STACKPTR) = CURTOKEN$
	STACKPTR = STACKPTR + 1
	RETURN

'pop
310 IF STACKPTR = 0 THEN PRINT "STACK UNDERFLOW": GOTO 50
	STACKPTR = STACKPTR - 1
	CURTOKEN$ = STACK$(STACKPTR)
	STACK$(STACKPTR) = ""
RETURN


'envstack push
350 ENVSTACK$(ENVSTACKPTR) = READLN$
    ENVSTACKPTR = ENVSTACKPTR + 1
	ENVSTACK$(ENVSTACKPTR) = CDR$
    ENVSTACKPTR = ENVSTACKPTR + 1
	ENVSTACK$(ENVSTACKPTR) = CURTOKEN$
    ENVSTACKPTR = ENVSTACKPTR + 1

RETURN

'envstack pop
360	ENVSTACKPTR = ENVSTACKPTR - 1
	CURTOKEN$ = ENVSTACK$(ENVSTACKPTR)
	ENVSTACKPTR = ENVSTACKPTR - 1
	CDR$ = ENVSTACK$(ENVSTACKPTR)
	ENVSTACKPTR = ENVSTACKPTR - 1
	READLN$ = ENVSTACK$(ENVSTACKPTR)
'print "CDR" ; CDR$
RETURN





'***************begin dictionary primitives
'drop
1000 GOSUB 310: CURTOKEN$="" : RETURN

'print
1010 GOSUB 310: PRINT CURTOKEN$; : RETURN

'println
1020 GOSUB 310: PRINT CURTOKEN$ : RETURN

'dup
1030 GOSUB 310:GOSUB 300:GOSUB 300: RETURN

'+
1040 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STR$(ARG1 + ARG2) :GOSUB 300: RETURN

'-
1050 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STR$(ARG1 - ARG2) :GOSUB 300: RETURN

'*
1060 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STR$(ARG1 * ARG2) :GOSUB 300: RETURN

'/
1070 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STR$(ARG1 / ARG2) :GOSUB 300: RETURN

'%
1080 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STR$(ARG1 MOD ARG2) :GOSUB 300: RETURN

'=
1090 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$)
	IF ARG1 = ARG2 THEN CURTOKEN$=TRUE$: GOSUB 300: RETURN
CURTOKEN$=FASLE$ : GOSUB 300: RETURN

'<
1100 :GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$)
	IF ARG1 < ARG2 THEN CURTOKEN$=TRUE$ : GOSUB 300: RETURN
CURTOKEN$=FASLE$ : GOSUB 300: RETURN

'>
1110 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$)
	IF ARG1 > ARG2 THEN CURTOKEN$=TRUE$ : GOSUB 300 :RETURN
CURTOKEN$=FALSE$ : GOSUB 300:RETURN

'EQ
1120 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$
	IF ARG1$ = ARG2$ THEN CURTOKEN$=TRUE$: GOSUB 300:RETURN
CURTOKEN$=FALSE$: GOSUB 300:RETURN

'BIND
1130 GOSUB 310: ARG1$=UPS$(CURTOKEN$): GOSUB 310: ARG2$ = CURTOKEN$

IF POS(DICTIONARY$(1), " " + ARG1$ + " ") > 0 THEN DICTDEF$(ARG1$) = ARG2$ : RETURN

DICTIONARY$(1)= DICTIONARY$(1) + ARG1$ + " ": DICTDEF$(ARG1$)=ARG2$ :RETURN



'WORDS
1140 CURTOKEN$ = RIGHT$(DICTIONARY$(0),LEN(DICTIONARY$(0)) - 1) + RIGHT$(DICTIONARY$(1),LEN(DICTIONARY$(1)) - 1): GOSUB 300: RETURN

'&
1150 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=ARG1$ + ARG2$ :GOSUB 300: RETURN

'SWAP
1160 GOSUB 310: ARG1$=CURTOKEN$ : GOSUB 310: ARG2$=CURTOKEN$: CURTOKEN$=ARG1$ :GOSUB 300: CURTOKEN$ = ARG2$: GOSUB 300: RETURN

'INP
1170 INPUT "",CURTOKEN$: GOSUB 300: RETURN

'CHAR
1180 GOSUB 310 :CURTOKEN$ = CHR$(VAL(CURTOKEN$)): GOSUB 300 : RETURN

'NE
1190 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$
	IF ARG1$ <> ARG2$ THEN CURTOKEN$=TRUE$: GOSUB 300:RETURN
CURTOKEN$=FALSE$: GOSUB 300:RETURN

'OVER
1200 GOSUB 310: ARG1$=CURTOKEN$ : GOSUB 310 : ARG2$=CURTOKEN$: GOSUB 300: CURTOKEN$ = ARG1$ : GOSUB 300: CURTOKEN$ = ARG2$ : GOSUB 300: RETURN

'SED
1210 GOSUB 310 : ARG4$=CURTOKEN$
GOSUB 310 : ARG3$=CURTOKEN$
GOSUB 310 : ARG2$=CURTOKEN$
GOSUB 310 : ARG1$=CURTOKEN$
CURTOKEN$= TH_SED$(ARG1$, ARG2$, ARG3$, ARG4$) : GOSUB 300
RETURN

'DESCRIBE
1220 GOSUB 310

IF POS(DICTIONARY$(1)," " + UPS$(CURTOKEN$) + " ") > 0 THEN CURTOKEN$ = DICTDEF$(UPS$(CURTOKEN$)) : GOSUB 300: RETURN

GOSUB 300 : RETURN

'EVAL
1230 GOSUB 310
    READLN$ = CURTOKEN$
	GOSUB 350 'evalstack push
	GOSUB 100
 	GOSUB 360 'evalstack pop
RETURN

'>R
1240 GOSUB 310: ENVSTACK$(ENVSTACKPTR) = CURTOKEN$ : ENVSTACKPTR = ENVSTACKPTR + 1 : RETURN

'R>
1250 ENVSTACKPTR = ENVSTACKPTR - 1 : CURTOKEN$ = ENVSTACK$(ENVSTACKPTR): GOSUB 300: RETURN

'UNBIND
1260 GOSUB 310: CURTOKEN$ = UPS$(CURTOKEN$)

DICTIONARY$(1) = TH_SED$(DICTIONARY$(1)," " + CURTOKEN$,"")

RETURN

'ROT
1270 GOSUB 310: ARG1$=CURTOKEN$ : GOSUB 310 : ARG2$=CURTOKEN$: GOSUB 310: ARG3$=CURTOKEN$: CURTOKEN$ = ARG2$ :GOSUB 300: CURTOKEN$ = ARG1$ : GOSUB 300: CURTOKEN$ = ARG3$: GOSUB 300 : RETURN

'TRUE
1280 CURTOKEN$=TRUE$ : GOSUB 300 : RETURN

'FALSE
1290 CURTOKEN$=FALSE$ : GOSUB 300 : RETURN

'SETTRUE
1300 GOSUB 310: TRUE$ = CURTOKEN$ :RETURN

'SETFALSE
1310 GOSUB 310: FALSE$ = CURTOKEN$ :RETURN

'DEPTH
1320 CURTOKEN$ = STR$(STACKPTR) : GOSUB 300 : RETURN

'R@
1330 CURTOKEN$ = ENVSTACK$(ENVSTACKPTR - 1): GOSUB 300: RETURN

'AND
1340 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=ARG1$ AND ARG2$ :GOSUB 300: RETURN

'OR
1350 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=ARG1$ OR ARG2$ :GOSUB 300: RETURN

'XOR
1360 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=ARG1$ XOR ARG2$ :GOSUB 300: RETURN

'NOT
1370 GOSUB 310: CURTOKEN$=STR$(NOT VAL(CURTOKEN$)) :GOSUB 300: RETURN

'ASC
1380 GOSUB 310: CURTOKEN$=STR$(ASC(CURTOKEN$)) :GOSUB 300: RETURN

'ATN
1390 GOSUB 310: CURTOKEN$=STR$(ATN(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'BIN
1400 GOSUB 310: CURTOKEN$=BIN$(VAL(CURTOKEN$)) :GOSUB 300: RETURN

'CINT
1410 GOSUB 310: CURTOKEN$=STR$(CINT(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'COLOR
1420 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): COLOR ARG1, ARG2 : RETURN

'COS 
1430 GOSUB 310: CURTOKEN$=STR$(COS(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'CSNG
1440 GOSUB 310: CURTOKEN$=STR$(CSNG(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'DIR
1450 CURTOKEN$=DIR$: GOSUB 300 : RETURN

'EOF
1460 CURTOKEN$=STR$(EOF(1)) :GOSUB 300: RETURN

'EXP
1470 GOSUB 310: CURTOKEN$=STR$(EXP(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'HEX
1480 GOSUB 310: CURTOKEN$=HEX$(VAL(CURTOKEN$)) :GOSUB 300: RETURN

'INKEY
1490 CURTOKEN$=INKEY$: GOSUB 300 : RETURN

'INSTR
1500 GOSUB 310 : ARG3=VAL(CURTOKEN$)
GOSUB 310 : ARG2$=CURTOKEN$
GOSUB 310 : ARG1$=CURTOKEN$
CURTOKEN$= STR$(INSTR(ARG1$, ARG2$, ARG3)) : GOSUB 300
RETURN

'INT
1510 GOSUB 310: CURTOKEN$=STR$(INT(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'LEFT
1520 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=LEFT$(ARG1$, ARG2) :GOSUB 300: RETURN

'LEN
1530 GOSUB 310: CURTOKEN$=STR$(LEN(CURTOKEN$)) :GOSUB 300: RETURN

'MOVETO
1540 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): LOCATE ARG1, ARG2  : RETURN

'LOG
1550 GOSUB 310: CURTOKEN$=STR$(LOG(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'LOG10
1560 GOSUB 310: CURTOKEN$=STR$(LOG10(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'MID
1570 GOSUB 310 : ARG3=VAL(CURTOKEN$)
GOSUB 310 : ARG2=VAL(CURTOKEN$)
GOSUB 310 : ARG1$=CURTOKEN$
CURTOKEN$= MID$(ARG1$, ARG2, ARG3) : GOSUB 300
RETURN

'NINT
1580 GOSUB 310: CURTOKEN$=STR$(NINT(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'OCT
1590 GOSUB 310: CURTOKEN$=OCT$(VAL(CURTOKEN$)) :GOSUB 300: RETURN

'PEEK
1600 GOSUB 310: CURTOKEN$=STR$(PEEK(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'POKE
1610 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): POKE ARG1,ARG2 : RETURN

'POLKEY
1620 GOSUB 310: ARG1=VAL(CURTOKEN$):CURTOKEN$=POLKEY$(ARG1) :GOSUB 300: RETURN

'PORT
1630 CURTOKEN$=STR$(PORT%) :GOSUB 300: RETURN

'POS
1640 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=STR$(POS(ARG1$, ARG2$)) :GOSUB 300: RETURN

'R2D
1650 GOSUB 310: CURTOKEN$=STR$(R2D(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'REC
1660 GOSUB 310: CURTOKEN$=STR$(REC(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'RIGHT
1670 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1$=CURTOKEN$: CURTOKEN$=RIGHT$(ARG1$, ARG2) :GOSUB 300: RETURN

'RND
1680 GOSUB 310: CURTOKEN$=STR$(RND(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'SCRATCH
1690 GOSUB 310: SCRATCH CURTOKEN$ : RETURN

'SGN
1700 GOSUB 310: CURTOKEN$=STR$(RND(SGN(CURTOKEN$))) :GOSUB 300: RETURN

'SIN
1710 GOSUB 310: CURTOKEN$=STR$(RND(SIN(CURTOKEN$))) :GOSUB 300: RETURN

'SLEEP
1720 GOSUB 310: SLEEP VAL(CURTOKEN$) : RETURN

'SQR
1730 GOSUB 310: CURTOKEN$=STR$(SQR(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'STRING
1740 GOSUB 310: ARG2$=CURTOKEN$ : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=STRING$(ARG1, ARG2$) :GOSUB 300: RETURN

'TAN
1750 GOSUB 310: CURTOKEN$=STR$(TAN(VAL(CURTOKEN$))) :GOSUB 300: RETURN

'SYSLEVEL
1760 GOSUB 310: CURTOKEN$=STR$(TH_SYSLEVEL(CURTOKEN$)) :GOSUB 300: RETURN

'HASBADGE
1770 GOSUB 310: CURTOKEN$=STR$(TH_HASBADGE(CURTOKEN$)) :GOSUB 300: RETURN

'HASLOGIN
1780 GOSUB 310: CURTOKEN$=STR$(TH_HASLOGIN(CURTOKEN$)) :GOSUB 300: RETURN

'HASROOT
1790 GOSUB 310: CURTOKEN$=STR$(TH_HASROOT(CURTOKEN$)) :GOSUB 300: RETURN

'HASSYSOP
1800 GOSUB 310: CURTOKEN$=STR$(TH_HASSYSOP(CURTOKEN$)) :GOSUB 300: RETURN

'HASADMIN
1810 GOSUB 310: CURTOKEN$=STR$(TH_HASSYSOP(CURTOKEN$)) :GOSUB 300: RETURN

'DEFGROUP
1820 CURTOKEN$=TH_DEFGROUP$ :GOSUB 300: RETURN

'PLAN
1830 CURTOKEN$=TH_PLAN$ :GOSUB 300: RETURN

'THTIME
1840 CURTOKEN$=str$(TH_TIME) :GOSUB 300: RETURN

'LOCALTIME
1850 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=TH_LOCALTIME$(ARG1,ARG2) :GOSUB 300: RETURN

'GMTIME
1860 GOSUB 310: ARG2=VAL(CURTOKEN$) : GOSUB 310: ARG1=VAL(CURTOKEN$): CURTOKEN$=TH_GMTIME$(ARG1,ARG2) :GOSUB 300: RETURN

'MODEM
1870 GOSUB 310: CURTOKEN$=TH_MODEM$(VAL(CURTOKEN$)) :GOSUB 300: RETURN

'HOSTNAME
1880 CURTOKEN$=TH_HOSTNAME$ :GOSUB 300: RETURN

'NETSTAT
1890 GOSUB 310: CURTOKEN$=TH_NETSTAT$(CURTOKEN$) :GOSUB 300: RETURN

'MD5HEX
1900 GOSUB 310: CURTOKEN$=TH_MD5HEX$(CURTOKEN$) :GOSUB 300: RETURN

'MD5BASE64
1910 GOSUB 310: CURTOKEN$=TH_MD5BASE64$(CURTOKEN$) :GOSUB 300: RETURN

'B64E
1920 GOSUB 310: CURTOKEN$=TH_B64E$(CURTOKEN$) :GOSUB 300: RETURN

'B64D
1930 GOSUB 310: CURTOKEN$=TH_B64D$(CURTOKEN$) :GOSUB 300: RETURN

'EXEC
1940 GOSUB 310: TH_EXEC CURTOKEN$, CURTOKEN$ :GOSUB 300: RETURN

'RE
1950 GOSUB 310 : ARG4=VAL(CURTOKEN$)
GOSUB 310 : ARG3=VAL(CURTOKEN$)
GOSUB 310 : ARG2$=CURTOKEN$
GOSUB 310 : ARG1$=CURTOKEN$
CURTOKEN$= STR$(TH_RE(ARG1$, ARG2$, ARG3, ARG4)) : GOSUB 300
RETURN

'RE$
1960 GOSUB 310 : ARG4=VAL(CURTOKEN$)
GOSUB 310 : ARG3=VAL(CURTOKEN$)
GOSUB 310 : ARG2$=CURTOKEN$
GOSUB 310 : ARG1$=CURTOKEN$
CURTOKEN$= TH_RE$(ARG1$, ARG2$, ARG3, ARG4) : GOSUB 300
RETURN

'REV
1970 GOSUB 310: CURTOKEN$=TH_REV$(CURTOKEN$) :GOSUB 300: RETURN

'UUD
1980 GOSUB 310: CURTOKEN$=TH_UUD$(CURTOKEN$) :GOSUB 300: RETURN

'UUE
1990 GOSUB 310: CURTOKEN$=TH_UUE$(CURTOKEN$) :GOSUB 300: RETURN

'TIM
2000 GOSUB 310: CURTOKEN$=STR$(TIM(VAL$(CURTOKEN$))) :GOSUB 300: RETURN

'TIME
2010 CURTOKEN$=TIME$:GOSUB 300: RETURN

'TIMER
2020 CURTOKEN$=STR$(TIME$):GOSUB 300: RETURN

'TYP
2030 GOSUB 310: CURTOKEN$=STR$(TYP(VAL$(CURTOKEN$))) :GOSUB 300: RETURN

'UPS
2040 GOSUB 310: CURTOKEN$=UPS$(CURTOKEN$) :GOSUB 300: RETURN

'USER
2050 CURTOKEN$=USER$:GOSUB 300: RETURN

'WIDTH
2060 CURTOKEN$=STR$(WIDTH):GOSUB 300: RETURN

'HEIGHT
2070 CURTOKEN$=STR$(HEIGHT):GOSUB 300: RETURN

'IFTE
2080 GOSUB 310: ARG1$ = CURTOKEN$
GOSUB 310: ARG2$ = CURTOKEN$
GOSUB 310: ARG3$ = CURTOKEN$
IF ARG3$ <> FALSE$ THEN GOSUB 350: READLN$ = ARG2$ :  GOSUB 100: GOSUB 360: RETURN 'if true, eval arg3
GOSUB 350: READLN$ = ARG1$ : GOSUB 100: GOSUB 360: RETURN

'WHILE
2090 GOSUB 310: ARG2$ = CURTOKEN$
	 GOSUB 310: ARG1$ = CURTOKEN$
2095 IF ARG1$ = FALSE$ THEN RETURN

CURTOKEN$ = ARG1$ : GOSUB 300
CURTOKEN$ = ARG2$ : GOSUB 300

ENVSTACK$(ENVSTACKPTR) = ARG2$ 'put current commandline on stack
ENVSTACKPTR = ENVSTACKPTR + 1

	GOSUB 1230 
	GOSUB 310: ARG1$ = CURTOKEN$
ENVSTACKPTR = ENVSTACKPTR - 1
ARG2$ = ENVSTACK$(ENVSTACKPTR)

GOTO 2095

'^
2100 GOSUB 310: ARG2 = VAL(CURTOKEN$): GOSUB 310: ARG1 = VAL(CURTOKEN$) : CURTOKEN$ = STR$(ARG1 ^ ARG2) : GOSUB 300 : RETURN

'USERDICT
2110 CURTOKEN$ = RIGHT$(DICTIONARY$(1),LEN(DICTIONARY$(1)) - 1): GOSUB 300: RETURN

'CANDR
2120 GOSUB 310
CURTOKEN$=TH_SED$(CURTOKEN$,"(^\s+)+","")' remove spaces

IF TH_RE(CURTOKEN$,"^~") THEN CURTOKEN$ = TH_RE(CURTOKEN$,"[^~]+",2) ' remove comments


'find CAR
IF TH_RE(CURTOKEN$,"^\{") THEN LEFTBRACE$ = "{" : RIGHTBRACE$ = "}" GOTO 2125
IF TH_RE(CURTOKEN$,"^\[") THEN LEFTBRACE$ = "[" : RIGHTBRACE$ = "]" GOTO 2125
IF TH_RE(CURTOKEN$,"^\(") THEN LEFTBRACE$ = "(" : RIGHTBRACE$ = ")" GOTO 2125 
IF NOT TH_RE(CURTOKEN$,"\s") THEN ARG1$ = CURTOKEN$ : ARG2$ = FALSE$ : GOTO 2123
ARG1$ = TH_RE$(CURTOKEN$,"[^\s]+",1)
ARG2$ = RIGHT$(CURTOKEN$, LEN(CURTOKEN$) - POS(CURTOKEN$," ") + 1) 'regex me later


'remove comments from CDR?


2123 CURTOKEN$ = ARG2$: GOSUB 300 ' push CDR
CURTOKEN$ = ARG1$ : GOSUB 300 ' push CAR

RETURN

2125 BRACES=1
FOR I = 2 TO LEN(CURTOKEN$)-1
	CURCHAR$ =MID$(CURTOKEN$,I,1)
	IF CURCHAR$ = RIGHTBRACE$ THEN BRACES = BRACES - 1
	IF CURCHAR$ = LEFTBRACE$ THEN BRACES = BRACES + 1
	IF BRACES = 0 THEN GOTO 2127
NEXT I
ARG1$ = CURTOKEN$ : ARG2$ = FALSE$ : GOTO 2123 'no cdr. This is set to false. Keep going back and forth if it should be null or not. probably should be null, but you can make null false so ...

2127 ARG1$ = LEFT$(CURTOKEN$,I) : ARG2$ = RIGHT$(CURTOKEN$, LEN(CURTOKEN$) - I ) : GOTO 2123


'IF
2130 GOSUB 310: ARG1$ = CURTOKEN$
GOSUB 310: ARG2$ = CURTOKEN$
IF ARG2$ <> FALSE$ THEN READLN$ = ARG1$ :  GOSUB 100: RETURN 'if true, eval arg2
 RETURN

'STACK
2140 CURTOKEN$ = "" : FOR I = 0 TO STACKPTR - 1 : CURTOKEN$ = CURTOKEN$ + STACK$(I) + " " : NEXT I : GOSUB 300 : RETURN


'LITSTACK
2150 CURTOKEN$ = "" : FOR I = 0 TO STACKPTR - 1 : CURTOKEN$ = CURTOKEN$ + "{" + STACK$(I) + "} " : NEXT I : GOSUB 300 : RETURN

'N>R
2160 GOSUB 	310 :ARG1= VAL(CURTOKEN$): FOR I = 1 TO ARG1 : GOSUB 310 : ENVSTACK$(ENVSTACKPTR) = CURTOKEN$ : ENVSTACKPTR = ENVSTACKPTR + 1 : NEXT I: ENVSTACK$(ENVSTACKPTR) = STR$(ARG1): ENVSTACKPTR = ENVSTACKPTR + 1 : RETURN


'NR>
2170 ENVSTACKPTR = ENVSTACKPTR - 1 : ARG1 = VAL(ENVSTACK$(ENVSTACKPTR)) : FOR I = 1 TO ARG1 :ENVSTACKPTR = ENVSTACKPTR - 1 : CURTOKEN$ = ENVSTACK$(ENVSTACKPTR) : GOSUB 300 : NEXT I : RETURN

'OPEN
2180 GOSUB 310: OPEN CURTOKEN$, AS #1: RETURN
RETURN

'APPEND
2190 GOSUB 310: OPEN CURTOKEN$, AS #1
2195 IF EOF(1) THEN RETURN
INPUT# 1, DUMP$
GOTO 2195

'WRITE
2200 GOSUB 310 : PRINT# 1,CURTOKEN$ : RETURN


'READ
2210 INPUT# 1,CURTOKEN$ : GOSUB 300 : RETURN

'CLOSE
2220 CLOSE #1 : RETURN

'SSCRATCH
2230 GOSUB 310: SCRATCH CURTOKEN$ ; TEMP$: RETURN

'BYE
2240 END

'QUOTE
2250 GOSUB 310 : CURTOKEN$ = "{" + CURTOKEN$ + "}" : GOSUB 300 : RETURN

'NEW
2260 CLS
STACK$(0) = ""
STACKPTR = 0
ENVSTACK$(0) = ""
ENVSTACKPTR = 0
TRUE$ = "1"
FALSE$ = "0"
GOSUB 10100 : RETURN

'.EXE
2270 GOSUB 310: TH_EXEC CURTOKEN$: RETURN

'CONS
2280 GOSUB 310: ARG1$ = CURTOKEN$ : GOSUB 310 : CURTOKEN$ = CURTOKEN$ + " " + ARG1$ : GOSUB 300: RETURN

'SELECT
2290 GOSUB 310 : ARG1$ = CURTOKEN$ READ #1,VAL(ARG1$);CURTOKEN$: GOSUB 300 : RETURN

'UPDATE
2300 GOSUB 310: ARG1$ = CURTOKEN$ : GOSUB 310 : PRINT #1,VAL(ARG1$);CURTOKEN$ : RETURN

'PICK
2310 GOSUB 310: ARG1 = INT(VAL(CURTOKEN$))
IF ARG1 >= 0 AND ARG1 < STACKPTR THEN CURTOKEN$ = STACK$(STACKPTR - ARG1 - 1) : GOSUB 300 : RETURN
CURTOKEN$ = "" : GOSUB 300 : RETURN

'**********************dictionary
10000 'DICTIONARY

DICTIONARY$(0) = " DROP PRIN1 . DUP + - * / % = < > EQ BIND WORDS & SWAP INPUT CHAR NE OVER SED DESCRIBE EVAL >R R> UNBIND ROT TRUE FALSE SETTRUE SETFALSE DEPTH R@ AND OR XOR NOT ASC ATN BIN CINT COLOR COS CSNG DIR EOF EXP HEX INKEY INSTR INT LEFT LEN MOVETO LOG LOG10 MID NINT OCT PEEK POKE POLKEY PORT POS R2D REC RIGHT RND SCRATCH SGN SIN SLEEP SQR STRING TAN SYSLEVEL HASBADGE HASLOGIN HASROOT HASSYSOP HASADMIN DEFGROUP PLAN TH_TIME LOCALTIME GMTIME MODEM HOSTNAME NETSTAT MD5HEX MD5BASE64 B64E B64D EXEC RE RE$ REV UUD UUE TIM TIME TIMER TYP UPS USER WIDTH HEIGHT IFTE WHILE ^ USERDICT CANDR IF STACK LITSTACK N>R NR> OPEN APPEND WRITE READ CLOSE SSCRATCH BYE QUOTE NEW .EXE CONS SELECT UPDATE PICK HELP "

FOR I = 1 TO TH_RE(DICTIONARY$(0),"\S+",1)
	WORDPOS(TH_RE$(DICTIONARY$(0),"\S+",I)) = I
NEXT I


10100 'BUILTIN DICTIONARY

DICTIONARY$(1) = " EMIT TRUE? FALSE? CLEARSTACK CAR CDR .W .S .U .L .D ` CAT DICT "

DICTDEF$("EMIT") = "~a --~ CHAR PRIN1"
DICTDEF$("CONS") = "~a a -- a~ SWAP { } & SWAP &" 'wrote this before I implemented over
DICTDEF$("TRUE?") = "~a -- a~ DUP TRUE EQ"
DICTDEF$("FALSE?") = "~a -- a~ DUP FALSE EQ"
DICTDEF$("CLEARSTACK") ="~a+ --~ DEPTH {DROP DROP DEPTH} WHILE"
DICTDEF$("CAR") = "~a -- a~ CANDR SWAP DROP"
DICTDEF$("CDR") = "~a -- a ~ CANDR DROP"
DICTDEF$(".W") = "~ -- ~ WORDS ."
DICTDEF$(".S") = "~ -- ~ STACK ."
DICTDEF$(".U") = "~ -- ~ USERDICT ."
DICTDEF$(".L") = "~ -- ~ LITSTACK ."
DICTDEF$(".D") = "~ -- ~ DESCRIBE ."
DICTDEF$("`") = "~a a -- ~ BIND"
DICTDEF$("CAT") = "~a a -- a~ SWAP 10 CHAR & SWAP &"
DICTDEF$("MOVETO") = "27 CHAR PRIN1 91 CHAR PRIN1 PRIN1 {;} PRIN1 PRIN1 {H} PRIN1"

RETURN


15000 'help

PRINT"Welcome to Haf, the lisp that's also a forth, floor wax, and dessert topping
PRINT"Expect things to change at any time as this is in extrememly early development
PRINT"
PRINT"Read the manual on pub, but here's some basics:
PRINT" . is the print command
PRINT"This is a stack machine, thus 3 4 + . will result in 7 being printed
PRINT"{} denotes a literal: {A B C} puts the string A B C on the stack
PRINT"[] denotes a conditional to be executed if the top of the stack is true (<>0)
PRINT"BIND binds the content of the second value to the name at the top of the stack
PRINT".W shows the contents of the dictionary.
PRINT"
PRINT"Sample programs:
PRINT"10 {1 - dup .} while ~this is a comment. there are loops~
PRINT"{DUP 1 > {DUP 1 - !} {1} IFTE *} ! bind 5 .~classic recursive factorial~
PRINT"{123 char swap & 125 char &} make-lit bind ~add your own words to haf!~
PRINT"{3 4 fnord} fnord {+} gi sed eval . ~self-modifying code via lambdas~
PRINT"
PRINT"BUGS: All. In particular the lexer is super brittle, and chokes if your braces
PRINT"don't match. Anything super fancy will eventually hit BASICs call stack limit
PRINT"so keep words short. Recursion is limited to about depth 10 as a result.
PRINT"Anything following while parens will get mangled. Solve by binding a new word.

RETURN